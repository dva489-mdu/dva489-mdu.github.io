<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>DVA446</title>

    <!-- Bootstrap -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/custom.css" rel="stylesheet">
    <link href="../css/print.css" rel="stylesheet" media="print">
    <link href="../css/prism.css" rel="stylesheet" />

    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<body>

    <!-- Begin page content -->
    <div class="container">

        <div class="page-header nobreak">
            <h2>My first mutli-tiered web application</h2>

            <p>
                In this laboration we will continue developing <a href="../lab3/my_first_social_media_app.html">Squeak!</a> by adding proper storage for credentials, sessions, and squeaks. We will connect the application to the popular <a href="https://www.mongodb.com/">MongoDB</a>,
                since MongoDB offers a free experimental tier with easy setup and excellent documentation.
            </p>


            <div class="alert alert-danger" role="alert">
                <h4 class="alert-heading">Warning!</h4>
                <p>
                    The final product of this is a web application intended to be open to attacks. The material presented in this laboration should not be seen as suggestions on how to build secure web applications. On the contrary, we have deliberately chosen some elements
                    to make sure that the application contains security flaws!
                </p>
            </div>

            <p>
                After completion of the steps below you are expected to have a working, but flawed, authenticated web application connected to MongoDB.
            </p>
        </div>

        <div class="page-header nobreak">
            <h2>Extending Squeak!</h2>
            <p>
                To make the database handling slightly more interesting we will extend Squeak! with private messages (squeals). To support this we make the following changes to the application.
            </p>

            <ol>
                <li>Add the possibility to squeak to all or to a specific recipient.</li>
                <li>Split the rendering of the posts into squeaks (sent to all) and squeals (sent to specific users).</li>
            </ol>

            <img src="squeak-squeal-example.png" class="img-responsive">

            <p>
                The image above depicts the situation where <a href="https://en.wikipedia.org/wiki/Alonzo_Church">A.
            Church</a> is logged in, has posted one squeak about the <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis">Church-Turing thesis</a>, and a squeal to himself reminding him to buy milk. The squeak form displays the default
                recipient <em>@
            Everyone</em>. To send a private message to <a href="https://en.wikipedia.org/wiki/Moses_Sch%C3%B6nfinkel">M. Sch&ouml;nfinkel</a> complimenting him on his outstanding work A. Church selects his name from the list of recipients before squeaking.
            </p>

            <img src="squeak-squeal-moses-example.png" class="img-responsive">

            <p>
                After having sent the squeal to M. Sch&ouml;nfinkel it is available. Notice how all public squeaks are still visible, while the squeal about milk is not, since it was private to A. Church.
            </p>

            <img src="squeak-squeal-reply-example.png" class="img-responsive">

            <p>
                To implement the changes I suggest adding a <a href="https://getbootstrap.com/docs/4.1/components/input-group/#custom-select">custom select</a> to the input group. See the HTML generated by the <a href="https://dva446.herokuapp.com/lab4">example
            application</a> for inspiration. To generate the select options, get the public squeaks and the private squeals we will use database queries. More on this below!
            </p>

        </div>


        <div class="page-header nobreak">
            <h2>Creating a MongoDB database</h2>

            <p>
                To create a MongoDB database you have to create an Atlas account and an
                <a href="https://docs.mongodb.com/manual/tutorial/atlas-free-tier-setup/#create-free-tier-manual">Atlas free
                tier cluster</a>. Follow the guide and the dashboard guidance to create a project to install the MongoDB driver and a get a connection string for driver 3.6 or later.
            </p>

            <p>
                MongoDB is a <a href="https://www.mongodb.com/nosql-explained">NoSQL</a> database which allows you to easily store and retrieve objects without having to care much about the structure of the database (for toy projects like this, in any
                case; for real projects more care is needed). In MongoDB, a database holds collections of objects. Both databases and collections are created on the fly if they don't exist.
            </p>

        </div>
        <div class="page-header nobreak">
            <h2>Programming asynchronously</h2>


            <p>
                A key behind the success of Node.js is the abundant use of asynchronous programming. While some libraries provide synchronous versions of the functions (e.g., <a href="https://nodejs.org/api/fs.html">File System</a>) many do not, which
                has a rather big impact on the way one programs. MongoDB belongs to the latter category and provides only an asynchronous API that can be used by passing continuations (callbacks) or using the new ES6
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">
                </a> Promises. Together with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await">await</a>                programming asynchronously with promises is almost as easy as writing synchronous code. See, e.g., MDN on
                <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">using promises</a>.
            </p>

        </div>


        <div class="page-header nobreak">
            <h2>Connecting to and using the database</h2>

            <div class="alert alert-danger" role="alert">
                <h4 class="alert-heading">Warning!</h4>
                <p>
                    For brevity, the code examples below lack error handling. Defensive programming requires you to properly handle the exception the operations may cause!
                </p>
            </div>

            <p>
                The NPM <a href="https://www.npmjs.com/package/mongodb">mongodb</a> package page contains a good getting started that explains how to connect to the server, how to create a database, how to create collections, how to add documents to collections
                and how to query collection. For detailed information look at the <a href="http://mongodb.github.io/node-mongodb-native/3.1/">driver documentation</a> for version 3.x. For the functionality the driver provides see the <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/">API</a>.
            </p>

            <div class="alert alert-warning" role="alert">
                <h4 class="alert-heading">On MongoDB authentication</h4>
                <p>
                    In the context of <a href="../lab2/my_first_authenticated_web_app.html">laboration 2</a> it might be interesting to read on the authentication mechanism <a href="https://docs.mongodb.com/manual/core/security-scram/">SCRAM</a> used
                    in MongoDB. Under what circumstances is it safe to include the password in the connection URL?
                </p>
            </div>
            <p>

            </p>

            <p>
                We are going to use three collections for Squeak!, one for the credentials, one for valid sessions and one for the squeaks. To connect, select the database and the collections simply use
            </p>

            <pre><code class="language-javascript">MongoClient.connect(mongoURL)
  .then((cluster) => {
      mongoCluster = cluster;

      let db = cluster.db('Squeak!');
      squeaks = db.collection('squeaks');
      credentials = db.collection('credentials');
      sessions = db.collection('sessions');

      let server = https.createServer(options, app);
      server.listen(8000);
    }
  )
  .catch((error) => {
      console.log(error);
    }
  );</code></pre>

            <p>This selects the database <code>Squeak!</code>, and the collections <code>credentials</code>,
                <code>sessions</code> and <code>squeaks</code>. If they are not present, they will be created on use. Notice the use of promises.
            </p>
        </div>
        <div class="page-header nobreak">

            <h3>Migrating the credentials</h3>
            <p>
                To migrate the credential we need to change the code for <em>signin</em> and <em>signup</em> to use the <em>credentials </em>collection.
            </p>

            <div class="alert alert-warning" role="alert">
                <h4 class="alert-heading">Observe!</h4>
                <p>
                    To diversify the NoSQL injection attacks we will not store the passwords in a secure way in MongoDB. Instead, the credentials will be stored as username/password pairs, e.g.,
                    <pre><code class="language-javascript">{ username : "daniel", password : "fisksoppa"}</code></pre> While this might feel counter-intuitive now that we have already addressed this issue it serves to illustrate how different vulnerabilities
                    work together to enable an attacker to compromise the application.
                </p>
            </div>

            <p>
                To authenticate provide an asynchronous function that queries the database for a username and password pair. This can be done using the <a href="https://docs.mongodb.com/manual/reference/method/db.collection.findOne/">findOne</a> collection
                method that takes a query (and an optional projection). In the case below, we look for an entry corresponding to the username and password. If such an entry is found, we know that the user exists and has provided the right password.
            </p>

            <pre><code class="language-javascript">async function authenticate(username, password) {
  let user = await credentials.findOne({username: username,
                                        password: password});
  return user !== null;
}</code></pre>

            <p>
                To add a user provide an asynchronous function that adds a username and password pair to the credentials collection. This can be done using the <a href="https://docs.mongodb.com/manual/reference/method/db.collection.insertOne/">insertOne</a>                collection method that takes a document (object) and inserts it into the database.
            </p>
            <pre><code class="language-javascript">async function addUser(username, password) {
  await credentials.insertOne({username: username, password: password});
}</code></pre>
            <p>
                Don't forget check if the user exists before adding! See the MongoDB <a href="https://docs.mongodb.com/manual/reference/">reference manual</a> or the MongoDB <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/">API</a> for more
                information.
            </p>
        </div>
        <div class="page-header nobreak">

            <h3>Migrating the sessions</h3>

            <p>
                To migrate the session handling we need to change the code for <em>signin</em>, <em>signup</em> and <em>signout</em>. Similar to <a href="../lab3/my_first_social_media_app.html">laboration 3</a> we store only the valid session identifiers
                in the server state. This allows for a simpler future transition to a more RESTful API.
            </p>
            <pre><code class="language-javascript">async function findSession(sessionid) {
  return await sessions.findOne({id: sessionid});
}</code></pre>

            <p>
                New sessions identifiers are allocated as 64 bytes of random data. There is a minuscule risk that the newly allocated identifier is the same as an already existing one. If this occurs a situation akin to session theft occurs. How substantial is this risk?
                Large enough to warrant defensive programming?
            </p>

            <pre><code class="language-javascript">async function newSession() {
  let sessionid = crypto.randomBytes(64).toString('hex');
  await sessions.insertOne({id: sessionid});
  return sessionid;
}</code></pre>

            <p>
                To invalidate a session we find remove the corresponding session information from the database. This can be done using the <a href="https://docs.mongodb.com/manual/reference/method/db.collection.findOneAndDelete/">findOneAndDelete</a>                collection method.
            </p>

            <pre><code class="language-javascript">async function invalidateSession(sessionid) {
  return await sessions.findOneAndDelete({id: sessionid});
}</code></pre>

        </div>
        <div class="page-header nobreak">

            <h3>Migrating the squeaks</h3>
            <p>
                Squeaks now contain the recipient in addition to the time of the squeak, the name of the squeaking user and the contents of the squeak. The username is fetched from the session cookie, while the recipient and the squeak contents are taken from the body
                of the request in line with <a href="../lab3/my_first_social_media_app.html">My first social media app</a>. For squeaks targeted at specific users, the recipient is a string containing the user-name. For public squeaks,
                the recipient string is
                <code>"all"</code>.
            </p>

            <pre><code class="language-javascript">async function addSqueak(username, recipient, squeak) {
  let options = {weekday: 'short', hour: 'numeric', minute: 'numeric'};
  let time = new Date().toLocaleDateString('sv-SE', options);
  await squeaks.insertOne({ name: username,
                            time: time,
                            recipient: recipient,
                            squeak: squeak});
}</code></pre>

            <p>
                To render the main page we need need to be able to fetch the public squeaks as well as the squeaks intended for a specific user.
            </p>

            <pre><code class="language-javascript">async function getSqueaks(recipient) {
  return await squeaks.find({ recipient : recipient }).toArray();
}</code></pre>

        </div>
        <div class="page-header nobreak">

            <h2>Rendering the application</h2>

            <p>
                As suggested in the <a href="../lab3/stored_xss.html">Stored XSS</a> attack, use an <a href="http://expressjs.com/">Express.js</a> compatible template engine such as <a href="https://mustache.github.io/">mustache</a> or <a href="https://handlebarsjs.com/">handlebars</a>.
                The <a href="https://dva446.herokuapp.com/lab4">example application</a> uses mustache to render the pages. The main page uses the username, a list of users, the public squeaks and the squeaks sent to the user to render the page. The interested
                can have a look at the <a href="https://bitbucket.org/snippets/dva446/oeb6L8">app.mustache</a> template.
            </p>


            <p>
                To render the main page fetch the users, the public squeaks and the private squeaks of the user. This can be done by using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">Promise.all()</a>                that take a list of promises and gives a list of results.
            </p>

            <pre><code class="language-javascript">Promise.all([getUsers(), getSqueaks('all'), getSqueaks(username),]).then(
  results => {
    res.render('app', {
      username: username,
      users: results[0],
      squeaks: results[1],
      squeals: results[2]
   });
});</code></pre>

            <p>
                The renderer is passed the username, the user database for rendering the selection, the public squeaks, i.e., squeaks with recipient <code>"all"</code>, and the squeaks with the user as the recipient. The username is taken from the session
                cookie.
            </p>
        </div>

        <div class="page-header nobreak">
            <h2>Final product</h2>
            <p>
                The final product of this laboration is a working, but flawed, authenticated social media web application connected to MongoDB. The application should support squeals, i.e., private squeaks. To squeak or squeal a user must log into the application.
            </p>

            <img src="squeak-signing.png" class="img-responsive">
            <p>
                After successful login, the user can squeak to all users or squeal to a specific user.
            </p>


            <img src="squeak-squeal-example.png" class="img-responsive">

            <p>
                The application should work similarly to the <a href="https://dva446.herokuapp.com/lab4">example application</a>. If you want to try it out you can log in using the names of the participants in the screenshots (mind the spaces! and password
                <code>12345678</code>! Notice that, for security reasons, squeaking, squealing and user registration are disabled in the example application.
            </p>
        </div>


        <script src="../js/prism.js"></script>

</body>

</html>